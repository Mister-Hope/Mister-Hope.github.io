"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[92525],{70789:(e,s,a)=>{a.r(s),a.d(s,{default:()=>b});var n=a(55511);const i=(0,n._)("p",null,[(0,n._)("code",null,"set"),(0,n.Uk)(" 命令是 Bash 脚本的重要环节，却常常被忽视，导致脚本的安全性和可维护性出问题。本章介绍 "),(0,n._)("code",null,"set"),(0,n.Uk)(" 的基本用法，帮助您写出更安全的 Bash 脚本。")],-1),l=(0,n.uE)('<h2 id="简介" tabindex="-1"><a class="header-anchor" href="#简介" aria-hidden="true">#</a> 简介</h2><p>我们知道，Bash 执行脚本时，会创建一个子 Shell。</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token function">bash</span> script.sh\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面代码中，<code>script.sh</code> 是在一个子 Shell 里面执行。这个子 Shell 就是脚本的执行环境，Bash 默认给定了这个环境的各种参数。</p>',4),c=(0,n._)("code",null,"set",-1),d={href:"https://www.gnu.org/software/bash/manual/html_node/The-Set-Builtin.html",target:"_blank",rel:"noopener noreferrer"},t=(0,n.uE)('<p>顺便提一下，如果命令行下不带任何参数，直接运行 <code>set</code>，会显示所有的环境变量和 Shell 函数。</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token builtin class-name">set</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="set-u" tabindex="-1"><a class="header-anchor" href="#set-u" aria-hidden="true">#</a> set -u</h2><p>执行脚本时，如果遇到不存在的变量，Bash 默认忽略它。</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token shebang important">#!/usr/bin/env bash</span>\n\n<span class="token builtin class-name">echo</span> <span class="token variable">$a</span>\n<span class="token builtin class-name">echo</span> bar\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面代码中，<code>$a</code> 是一个不存在的变量。执行结果如下。</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>$ <span class="token function">bash</span> script.sh\n\nbar\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到，<code>echo $a</code> 输出了一个空行，Bash 忽略了不存在的 <code>$a</code>，然后继续执行 <code>echo bar</code>。大多数情况下，这不是开发者想要的行为，遇到变量不存在，脚本应该报错，而不是一声不响地往下执行。</p><p><code>set -u</code> 就用来改变这种行为。脚本在头部加上它，遇到不存在的变量就会报错，并停止执行。</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token shebang important">#!/usr/bin/env bash</span>\n<span class="token builtin class-name">set</span> <span class="token parameter variable">-u</span>\n\n<span class="token builtin class-name">echo</span> <span class="token variable">$a</span>\n<span class="token builtin class-name">echo</span> bar\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>运行结果如下。</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>$ <span class="token function">bash</span> script.sh\nbash: script.sh:行4: a: 未绑定的变量\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到，脚本报错了，并且不再执行后面的语句。</p><p><code>-u</code> 还有另一种写法 <code>-o nounset</code>，两者是等价的。</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token builtin class-name">set</span> <span class="token parameter variable">-o</span> nounset\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="set-x" tabindex="-1"><a class="header-anchor" href="#set-x" aria-hidden="true">#</a> set -x</h2><p>默认情况下，脚本执行后，只输出运行结果，没有其他内容。如果多个命令连续执行，它们的运行结果就会连续输出。有时会分不清，某一段内容是什么命令产生的。</p><p><code>set -x</code> 用来在运行结果之前，先输出执行的那一行命令。</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token shebang important">#!/usr/bin/env bash</span>\n<span class="token builtin class-name">set</span> <span class="token parameter variable">-x</span>\n\n<span class="token builtin class-name">echo</span> bar\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>执行上面的脚本，结果如下。</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>$ <span class="token function">bash</span> script.sh\n+ <span class="token builtin class-name">echo</span> bar\nbar\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到，执行 <code>echo bar</code> 之前，该命令会先打印出来，行首以 <code>+</code> 表示。这对于调试复杂的脚本是很有用的。</p><p><code>-x</code> 还有另一种写法 <code>-o xtrace</code>。</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token builtin class-name">set</span> <span class="token parameter variable">-o</span> xtrace\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>脚本当中如果要关闭命令输出，可以使用 <code>set +x</code>。</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token shebang important">#!/bin/bash</span>\n\n<span class="token assign-left variable">number</span><span class="token operator">=</span><span class="token number">1</span>\n\n<span class="token builtin class-name">set</span> <span class="token parameter variable">-x</span>\n<span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token variable">$number</span> <span class="token operator">=</span> <span class="token string">&quot;1&quot;</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>\n  <span class="token builtin class-name">echo</span> <span class="token string">&quot;Number equals 1&quot;</span>\n<span class="token keyword">else</span>\n  <span class="token builtin class-name">echo</span> <span class="token string">&quot;Number does not equal 1&quot;</span>\n<span class="token keyword">fi</span>\n<span class="token builtin class-name">set</span> +x\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的例子中，只对特定的代码段打开命令输出。</p><h2 id="bash-的错误处理" tabindex="-1"><a class="header-anchor" href="#bash-的错误处理" aria-hidden="true">#</a> Bash 的错误处理</h2><p>如果脚本里面有运行失败的命令(返回值非 <code>0</code>)，Bash 默认会继续执行后面的命令。</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token shebang important">#!/usr/bin/env bash</span>\n\nfoo\n<span class="token builtin class-name">echo</span> bar\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面脚本中，<code>foo</code> 是一个不存在的命令，执行时会报错。但是，Bash 会忽略这个错误，继续往下执行。</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>$ <span class="token function">bash</span> script.sh\nscript.sh:行3: foo: 未找到命令\nbar\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到，Bash 只是显示有错误，并没有终止执行。</p><p>这种行为很不利于脚本安全和除错。实际开发中，如果某个命令失败，往往需要脚本停止执行，防止错误累积。这时，一般采用下面的写法。</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token builtin class-name">command</span> <span class="token operator">||</span> <span class="token builtin class-name">exit</span> <span class="token number">1</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面的写法表示只要 <code>command</code> 有非零返回值，脚本就会停止执行。</p><p>如果停止执行之前需要完成多个操作，就要采用下面三种写法。</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token comment"># 写法一</span>\n<span class="token builtin class-name">command</span> <span class="token operator">||</span> <span class="token punctuation">{</span> <span class="token builtin class-name">echo</span> <span class="token string">&quot;command failed&quot;</span><span class="token punctuation">;</span> <span class="token builtin class-name">exit</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>\n\n<span class="token comment"># 写法二</span>\n<span class="token keyword">if</span> <span class="token operator">!</span> <span class="token builtin class-name">command</span><span class="token punctuation">;</span> <span class="token keyword">then</span> <span class="token builtin class-name">echo</span> <span class="token string">&quot;command failed&quot;</span><span class="token punctuation">;</span> <span class="token builtin class-name">exit</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token keyword">fi</span>\n\n<span class="token comment"># 写法三</span>\n<span class="token builtin class-name">command</span>\n<span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token string">&quot;<span class="token variable">$?</span>&quot;</span> <span class="token parameter variable">-ne</span> <span class="token number">0</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span> <span class="token builtin class-name">echo</span> <span class="token string">&quot;command failed&quot;</span><span class="token punctuation">;</span> <span class="token builtin class-name">exit</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token keyword">fi</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>另外，除了停止执行，还有一种情况。如果两个命令有继承关系，只有第一个命令成功了，才能继续执行第二个命令，那么就要采用下面的写法。</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>command1 <span class="token operator">&amp;&amp;</span> command2\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="set-e" tabindex="-1"><a class="header-anchor" href="#set-e" aria-hidden="true">#</a> set -e</h2><p>上面这些写法多少有些麻烦，容易疏忽。<code>set -e</code> 从根本上解决了这个问题，它使得脚本只要发生错误，就终止执行。</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token shebang important">#!/usr/bin/env bash</span>\n<span class="token builtin class-name">set</span> <span class="token parameter variable">-e</span>\n\nfoo\n<span class="token builtin class-name">echo</span> bar\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>执行结果如下。</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>$ <span class="token function">bash</span> script.sh\nscript.sh:行4: foo: 未找到命令\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到，第 4 行执行失败以后，脚本就终止执行了。</p><p><code>set -e</code> 根据返回值来判断，一个命令是否运行失败。但是，某些命令的非零返回值可能不表示失败，或者开发者希望在命令失败的情况下，脚本继续执行下去。这时可以暂时关闭 <code>set -e</code>，该命令执行结束后，再重新打开 <code>set -e</code>。</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token builtin class-name">set</span> +e\ncommand1\ncommand2\n<span class="token builtin class-name">set</span> <span class="token parameter variable">-e</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面代码中，<code>set +e</code> 表示关闭 <code>-e</code> 选项，<code>set -e</code> 表示重新打开 <code>-e</code> 选项。</p><p>还有一种方法是使用 <code>command || true</code>，使得该命令即使执行失败，脚本也不会终止执行。</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token shebang important">#!/bin/bash</span>\n<span class="token builtin class-name">set</span> <span class="token parameter variable">-e</span>\n\nfoo <span class="token operator">||</span> <span class="token boolean">true</span>\n<span class="token builtin class-name">echo</span> bar\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面代码中，<code>true</code> 使得这一行语句总是会执行成功，后面的 <code>echo bar</code> 会执行。</p><p><code>-e</code> 还有另一种写法 <code>-o errexit</code>。</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token builtin class-name">set</span> <span class="token parameter variable">-o</span> errexit\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="set-o-pipefail" tabindex="-1"><a class="header-anchor" href="#set-o-pipefail" aria-hidden="true">#</a> set -o pipefail</h2><p><code>set -e</code> 有一个例外情况，就是不适用于管道命令。</p><p>所谓管道命令，就是多个子命令通过管道运算符 (<code>|</code>) 组合成为一个大的命令。Bash 会把最后一个子命令的返回值，作为整个命令的返回值。也就是说，只要最后一个子命令不失败，管道命令总是会执行成功，因此它后面命令依然会执行，<code>set -e</code> 就失效了。</p><p>请看下面这个例子。</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token shebang important">#!/usr/bin/env bash</span>\n<span class="token builtin class-name">set</span> <span class="token parameter variable">-e</span>\n\nfoo <span class="token operator">|</span> <span class="token builtin class-name">echo</span> a\n<span class="token builtin class-name">echo</span> bar\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>执行结果如下。</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>$ <span class="token function">bash</span> script.sh\na\nscript.sh:行4: foo: 未找到命令\nbar\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面代码中，<code>foo</code> 是一个不存在的命令，但是 <code>foo | echo a</code> 这个管道命令会执行成功，导致后面的 <code>echo bar</code> 会继续执行。</p><p><code>set -o pipefail</code> 用来解决这种情况，只要一个子命令失败，整个管道命令就失败，脚本就会终止执行。</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token shebang important">#!/usr/bin/env bash</span>\n<span class="token builtin class-name">set</span> <span class="token parameter variable">-eo</span> pipefail\n\nfoo <span class="token operator">|</span> <span class="token builtin class-name">echo</span> a\n<span class="token builtin class-name">echo</span> bar\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>运行后，结果如下。</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>$ <span class="token function">bash</span> script.sh\na\nscript.sh:行4: foo: 未找到命令\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到，<code>echo bar</code> 没有执行。</p><h2 id="其他参数" tabindex="-1"><a class="header-anchor" href="#其他参数" aria-hidden="true">#</a> 其他参数</h2><p><code>set</code> 命令还有一些其他参数。</p><ul><li><code>set -n</code>: 等同于 <code>set -o noexec</code>，不运行命令，只检查语法是否正确。</li><li><code>set -f</code>: 等同于 <code>set -o noglob</code>，表示不对通配符进行文件名扩展。</li><li><code>set -v</code>: 等同于 <code>set -o verbose</code>，表示打印 Shell 接收到的每一行输入。</li></ul><p>上面的 <code>-f</code> 和 <code>-v</code> 参数，可以分别使用 <code>set +f</code>、<code>set +v</code> 关闭。</p><h2 id="set-命令总结" tabindex="-1"><a class="header-anchor" href="#set-命令总结" aria-hidden="true">#</a> set 命令总结</h2><p>上面重点介绍的 <code>set</code> 命令的四个参数，一般都放在一起使用。</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token comment"># 写法一</span>\n<span class="token builtin class-name">set</span> <span class="token parameter variable">-euxo</span> pipefail\n\n<span class="token comment"># 写法二</span>\n<span class="token builtin class-name">set</span> <span class="token parameter variable">-eux</span>\n<span class="token builtin class-name">set</span> <span class="token parameter variable">-o</span> pipefail\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这两种写法建议放在所有 Bash 脚本的头部。</p><p>另一种办法是在执行 Bash 脚本的时候，从命令行传入这些参数。</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token function">bash</span> <span class="token parameter variable">-euxo</span> pipefail script.sh\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="shopt-命令" tabindex="-1"><a class="header-anchor" href="#shopt-命令" aria-hidden="true">#</a> shopt 命令</h2><p><code>shopt</code> 命令用来调整 Shell 的参数，跟 <code>set</code> 命令的作用很类似。之所以会有这两个类似命令的主要原因是，<code>set</code> 是从 Ksh 继承的，属于 POSIX 规范的一部分，而 <code>shopt</code> 是 Bash 特有的。</p><p>直接输入 <code>shopt</code> 可以查看所有参数，以及它们各自打开和关闭的状态。</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token builtin class-name">shopt</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><code>shopt</code> 命令后面跟着参数名，可以查询该参数是否打开。</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>$ <span class="token builtin class-name">shopt</span> globstar\nglobstar  off\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>上面例子表示 <code>globstar</code> 参数默认是关闭的。</p><ol><li><p><strong><code>-s</code></strong></p><p><code>-s</code> 用来打开某个参数。</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token builtin class-name">shopt</span> <span class="token parameter variable">-s</span> optionNameHere\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li><li><p><strong><code>-u</code></strong></p><p><code>-u</code> 用来关闭某个参数。</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token builtin class-name">shopt</span> <span class="token parameter variable">-u</span> optionNameHere\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>举例来说，<code>histappend</code> 这个参数表示退出当前 Shell 时，将操作历史追加到历史文件中。这个参数默认是打开的，如果使用下面的命令将其关闭，那么当前 Shell 的操作历史将替换掉整个历史文件。</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token builtin class-name">shopt</span> <span class="token parameter variable">-u</span> histappend\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li><li><p><strong><code>-q</code></strong></p><p><code>-q</code> 的作用也是查询某个参数是否打开，但不是直接输出查询结果，而是通过命令的执行状态 (<code>$?</code>) 表示查询结果。如果状态为 <code>0</code>，表示该参数打开；如果为 <code>1</code>，表示该参数关闭。</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>$ <span class="token builtin class-name">shopt</span> <span class="token parameter variable">-q</span> globstar\n$ <span class="token builtin class-name">echo</span> <span class="token variable">$?</span>\n<span class="token number">1</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面命令查询 <code>globstar</code> 参数是否打开。返回状态为 <code>1</code>，表示该参数是关闭的。</p><p>这个用法主要用于脚本，供 <code>if</code> 条件结构使用。</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token keyword">if</span> <span class="token builtin class-name">shopt</span> <span class="token parameter variable">-q</span> globstar<span class="token punctuation">;</span> <span class="token keyword">then</span>\n  <span class="token punctuation">..</span>.\n<span class="token keyword">if</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ol><h2 id="参考链接" tabindex="-1"><a class="header-anchor" href="#参考链接" aria-hidden="true">#</a> 参考链接</h2>',86),o={href:"https://www.gnu.org/software/bash/manual/html_node/The-Set-Builtin.html",target:"_blank",rel:"noopener noreferrer"},r={href:"https://vaneyckt.io/posts/safer_bash_scripts_with_set_euxo_pipefail/",target:"_blank",rel:"noopener noreferrer"},p={href:"http://www.davidpashley.com/articles/writing-robust-shell-scripts/",target:"_blank",rel:"noopener noreferrer"},u={},b=(0,a(61935).Z)(u,[["render",function(e,s){const a=(0,n.up)("ExternalLinkIcon");return(0,n.wg)(),(0,n.iD)("div",null,[i,(0,n.kq)(" more "),l,(0,n._)("p",null,[c,(0,n.Uk)(" 命令用来修改子 Shell 环境的运行参数，即定制环境。一共有十几个参数可以定制，"),(0,n._)("a",d,[(0,n.Uk)("官方手册"),(0,n.Wm)(a)]),(0,n.Uk)("有完整清单，本章介绍其中最常用的几个。")]),t,(0,n._)("ul",null,[(0,n._)("li",null,[(0,n._)("a",o,[(0,n.Uk)("The Set built-in"),(0,n.Wm)(a)])]),(0,n._)("li",null,[(0,n._)("a",r,[(0,n.Uk)("Safer bash scripts with 'set -euxo pipefail’"),(0,n.Wm)(a)])]),(0,n._)("li",null,[(0,n._)("a",p,[(0,n.Uk)("Writing Robust Bash Shell Scripts"),(0,n.Wm)(a)])])])])}]])},61935:(e,s)=>{s.Z=(e,s)=>{const a=e.__vccOpts||e;for(const[e,n]of s)a[e]=n;return a}},40923:(e,s,a)=>{a.r(s),a.d(s,{data:()=>n});const n=JSON.parse('{"key":"v-8c4eb5c4","path":"/linux/bash/set.html","title":"set 命令","lang":"zh-CN","frontmatter":{"title":"set 命令","icon":"set","author":"阮一峰","category":["Linux"],"tag":["Bash"],"copyright":"本教程采用<a href=\\"https://creativecommons.org/licenses/by-sa/3.0/deed.zh\\" rel=\\"noopener noreferrer\\" target=\\"_blank\\">知识共享 署名-相同方式共享 3.0协议</a>","summary":"set 命令是 Bash 脚本的重要环节，却常常被忽视，导致脚本的安全性和可维护性出问题。本章介绍 set 的基本用法，帮助您写出更安全的 Bash 脚本。\\n","head":[["meta",{"property":"og:url","content":"https://mrhope.site/linux/bash/set.html"}],["meta",{"property":"og:site_name","content":"Mr.Hope"}],["meta",{"property":"og:title","content":"set 命令"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:updated_time","content":"2022-02-12T05:50:30.000Z"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"阮一峰"}],["meta",{"property":"article:tag","content":"Bash"}],["meta",{"property":"article:modified_time","content":"2022-02-12T05:50:30.000Z"}]]},"excerpt":"<p><code v-pre>set</code> 命令是 Bash 脚本的重要环节，却常常被忽视，导致脚本的安全性和可维护性出问题。本章介绍 <code v-pre>set</code> 的基本用法，帮助您写出更安全的 Bash 脚本。</p>\\n","headers":[{"level":2,"title":"简介","slug":"简介","link":"#简介","children":[]},{"level":2,"title":"set -u","slug":"set-u","link":"#set-u","children":[]},{"level":2,"title":"set -x","slug":"set-x","link":"#set-x","children":[]},{"level":2,"title":"Bash 的错误处理","slug":"bash-的错误处理","link":"#bash-的错误处理","children":[]},{"level":2,"title":"set -e","slug":"set-e","link":"#set-e","children":[]},{"level":2,"title":"set -o pipefail","slug":"set-o-pipefail","link":"#set-o-pipefail","children":[]},{"level":2,"title":"其他参数","slug":"其他参数","link":"#其他参数","children":[]},{"level":2,"title":"set 命令总结","slug":"set-命令总结","link":"#set-命令总结","children":[]},{"level":2,"title":"shopt 命令","slug":"shopt-命令","link":"#shopt-命令","children":[]},{"level":2,"title":"参考链接","slug":"参考链接","link":"#参考链接","children":[]}],"git":{"createdTime":1591204114000,"updatedTime":1644645030000,"contributors":[{"name":"Mr.Hope","email":"zhangbowang1998@gmail.com","commits":8}]},"readingTime":{"minutes":7.49,"words":2248},"filePathRelative":"linux/bash/set.md","localizedDate":"2020年6月3日"}')}}]);